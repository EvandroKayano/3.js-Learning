GLSL -> OpenGL Shading Language
Programming language that can communicate with de GPU

int, float, bool

vectors&matrices
Recommendation: Freya HolmÃ©r

VECTORS: vec(float), ivec(int), bvec(bool)
vec2 vectA = vec2(1.0, 6.0); // vec2 = 2 elements

vec4 vect = vec4(1.0, 2.0, 3.0, 4.0);
// a1==a2==a3== 1.0     b1==b2==b3== 2.0        c1==c2==c3== 3.0        d1==d2==d3== 4.0
float a1 = vect.x;      float b1 = vect.y;      float c1 = vect.z;      float d1 = vect.w;
float a2 = vect.r;      float b2 = vect.g;      float c2 = vect.b;      float d2 = vect.a;
float a3 = vect.s;      float b3 = vect.t;      float c3 = vect.p;      float d3 = vect.q;

vec2 vectB = vect.xz; // (1.0, 3.0)

MATRICES:   |7.0, 0.0, 1.0,|
            |4.0, 2.0, 3.0,| => mat3 mat = mat3(7.0, 0.0, 1.0,      4.0, 2.0, 3.0,      5.0, 5.0, 7.0);
            |5.0, 5.0, 7.0 |

vec3 vec = mat[0]; // [7.0, 0.0, 1.0]
float f = mat[2][2]; // 7.0 
// f = mat[2]z;

SAMPLER (2D e Cube)
ARRAY
STRUCT

if elseif else for

STORAGE QUALIFIERS
const 
attribute -> positions (only in vertexShaders)
uniform -> time (vertex and fragment shaders)
varying -> transfer value from vertexS to fragmentS

PRECISION QUALIFIERS
lowp mediump highp
precision_qualifier type variable_identifier; // mediump float f;
precision precision_qualifier type; // precision highp vec2;

SHADERS
program written in GLSL:

- vertexShader: takes care of positioning every vertex composing the mesh
void main(){
    // Instructions
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);  
    //gl_Position - where to draw the final position of the current vertex
    //projectionMatrix and modelViewMatrix - built-in uniforms to calculate final position of the vertex
    // vec4(position, 1.0) - vertex's default coordinates

}

- fragmentShader: color verteces and meshes that they form
void main(){
    //Instructions
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    //   from 0.0 - 1.0  R    G    B    A(opacity)
    //gl_FragColor - color of one fragment
}


in the video he uses a const uniforms to pass information to the shaders
than he attaches the uniforms to the object material

in the animate part, he passes the time(elapseTime) through the uniforms to the shaders

in the vertexShader main, he sets a new position to x, by using time as a variable

in the fragmentShader main, the color will change according o elapsedTime, also
the further right (axel X), the greener the color, for that he normalizes the coodinates from 0.0 to 1.0
he also changes the color based on the mouse position,
sends a image as information for the fragmentShader

at this point the image sent is used as the whole screen, to make the plane get the image, we need to pass its
width and height, unfortunately de fragmentShader doens't have a variable to contain that info, however 3.js has
provides an attribute under the name of UV, so all we need to do is to pass that info from the vertexShader to 
the fragmentShader.